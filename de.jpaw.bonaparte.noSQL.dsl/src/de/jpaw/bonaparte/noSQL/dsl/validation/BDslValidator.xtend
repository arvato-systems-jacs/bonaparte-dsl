/*
 * generated by Xtext
 */
package de.jpaw.bonaparte.noSQL.dsl.validation

import de.jpaw.bonaparte.dsl.bonScript.ClassDefinition
import static extension de.jpaw.bonaparte.dsl.generator.XUtil.*
import de.jpaw.bonaparte.noSQL.dsl.bDsl.BDslPackage
import de.jpaw.bonaparte.noSQL.dsl.bDsl.EntityDefinition
import de.jpaw.bonaparte.noSQL.dsl.bDsl.StorageProvider
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.validation.Check

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class BDslValidator extends AbstractBDslValidator {

    def void checkParentOf(ClassDefinition parent, ClassDefinition of, String msg, EReference whereIsTheProblem) {
        var e = parent
        while (e !== null) {
            if (e === of)
                return;
            e = e.extendsClass?.classRef
        }
        error(msg, whereIsTheProblem)
    }
    
    @Check
    def checkEntityDefinition(EntityDefinition e) {
        // with aerospike, indexes must be single column...
        if (e.provider == StorageProvider.AEROSPIKE) {
            if (e.pk === null || e.pk.columnName.empty)
                error("PK must be provided for this persistence type", BDslPackage.Literals.ENTITY_DEFINITION__PK)
            for (i : e.indexes) {
                if (i.isIsUnique)
                    error('''nonunique indexes supported only for Aerospike''', BDslPackage.Literals.ENTITY_DEFINITION__PROVIDER)
                else if (i.name === null)
                    error('''indexes must have a name for Aerospike''', BDslPackage.Literals.ENTITY_DEFINITION__PROVIDER)
                else if (i.columns.columnName.size > 1)
                    error('''only single column indexes supported currently for Aerospike''', BDslPackage.Literals.ENTITY_DEFINITION__PROVIDER)
            }
        } else {
            // non Aerospike
            if (e.pk !== null)
                error("PK must be defined in bon file for this persistence type", BDslPackage.Literals.ENTITY_DEFINITION__PK)
            val refClass = e.pojoType.recurseRefClass
            val pkClass = e.pojoType.recursePkClass 
            if (refClass === null)
                error('''Need ref class''', BDslPackage.Literals.ENTITY_DEFINITION__POJO_TYPE)
            if (pkClass === null)
                error('''Need object type primary key''', BDslPackage.Literals.ENTITY_DEFINITION__POJO_TYPE)
            
//            if (e.tableCategory.trackingColumns === null) {
//                error('''category must specify tracking columns''', BDslPackage.Literals.ENTITY_DEFINITION__TABLE_CATEGORY)
//            }
            checkParentOf(pkClass, refClass, "PK must be a parent of ref", BDslPackage.Literals.ENTITY_DEFINITION__POJO_TYPE)
            checkParentOf(e.pojoType, pkClass, "DTO must be a parent of PK", BDslPackage.Literals.ENTITY_DEFINITION__POJO_TYPE)
        }
    }
}
